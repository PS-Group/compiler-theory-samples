# Интерпретатор с LALR-парсером внутри

Интерпретатор получает ввод построчно и интепретирует каждую строку либо как присвоение переменной, либо как команду `print X`.

##### Ввод
```
print 21 + 13 - (1.12 * 2 - 1.51 / 2)
x = 10
y = 12.2
print x*y
```

##### Вывод
```
result: 32.515
result: 122
```

### Отличия от примера lemon-1-calculator

- Добавлены новые токены (*терминалы*) `TK_NEWLINE`, `TK_ID`, `TK_ASSIGN`, `TK_PRINT`.
- Добавлены новые правила (*нетерминалы*) `statement_line`, `statement_lines_list`.
- Структура `struct SToken` хранит номер строки и колонки, где встретился токен, а также дополнительные данные внутри `union`. Хотя `union` и является опасным отступлением к стилю языка C, его использование оправдано, так как сгенерированный утилитой Lemon код всё равно поместит `SToken` в `union`.
- Класс `CCalcLexer` переименован в `CBatchLexer`, и разбирает на токены одну строку кода.

![include map](img/BatchLexer_includemap.png)

- Класс `CCalcParser` переименован в `CBatchParser`, и получил 3 новых метода, которые вызываются из атрибутных действий в грамматике для Lemon.

![include map](img/BatchParser_includemap.png)

- Новый класс `CInterpreterContext` ведёт список переменных и реагирует на события парсера.

![include map](img/InterpreterContext_includemap.png)

- Новый класс `CStringPool` используется, чтобы превратить строковое имя переменной в уникальный ID типа `unsigned int`. Это сделано ради обхода ограничений Lemon: мы не можем поместить в структуру `SToken` ничего, что имеет нетривиальный конструктор, а `std::string` имеет нетривиальный конструктор. Помещение строк в единый пул строк также называется `string pooling` или `interning`. Методика можно применять не только для обхода ограничений, но и в целях оптимизации производительности и потребления памяти.

![include map](img/StringPool_includemap.png)

### Особенности применения Lemon в примере

- Обработки ошибок нет, любая ошибка парсера завершает работу интерпретатоа.
- Правило `statement_line` добавлено, чтобы гарантировать, что свёртка правила `statement` и выполнение атрибутного действия свёртки произойдут сразу после получения токена `NEWLINE`. В отличии от Bison, с Lemon парсер не будет сворачивать правило `statement` сразу при получении токена `NEWLINE` &mdash; он будет ждать, пока выбор свёртки не станет однозначным.
- Если убрать `statement_line`, тогда команда `print` будет отставать на одну строку. Пример:

##### Ввод
```
print 3
print 2
<ожидаем ввода>
```

##### Вывод
```
3
<ожидаем ввода>
```

### Системные требования

- Для ОС Ubuntu: установите пакет `lemon`
- Для ОС Windows: соберите Lemon из [исходных кодов (hwaci.com)](http://www.hwaci.com/sw/lemon/). Исходники Lemon состоят всего из двух файлов, `lemon.c` и `lempar.c`. Используйте любой современный компилятор C/C++.
